#include <array>
#include <exception>
#include <iostream>
#include <cstdlib>
#include <vector>


/* 
    # 递归函数的设计技巧

    ## 1、数学归纳法

    什么是数学归纳法？

    例：如何证明P(n)成立？

    1. Step1：验证P(1)成立
    2. Step2：证明如果P(K)成立，那么P(K + 1)也成立
    3. Step3：联合Step1与Step2，证明由P(1) -> P(n)成立

    > 题目一

    证明：1 + 3 + ... + (2n - 1) = n² 👈 （证明前n项的奇数和等于n次方）

    ``` 
    第一步：证明P(1)
    👉  P(1) = 1 = 1²

    第二步：假设P(K)正确，证明P(K + 1)
    👉  假设P(n - 1) = (n - 1)²
    👉  那么，前n - 1项的奇数和 + 第n项的奇数为：(n - 1)²+(2n - 1)
    👉  上述式子`(n - 1)²+(2n - 1)`展开化简后等于：n²。
    👉  至此，证明了如果P(K)正确，P(K + 1)也正确

    第三步：
    👉  因为，P(1)正确，又因为：假设P(K)正确，P(K + 1)也正确，
    👉  所以：`1 + 3 + ... + (2n - 1) = n²`式子正确 
    ```

    > 题目二

    证明如下程序的正确性👇

    ``` C++
    int main() {
        int sum = 0;                            👈 这个是p(1),前0项的和
        for(int i = 1; i <= 100; i++) {         👈 i代表了K + 1
            sum += i;                           👈 sum代表了p(K)，前K项的和，i = K + 1，所以该行执行完后，sum代表前K + 1项的和,P(K + 1)
        }
        cout << sum << endl;
        return 0;
    }
    ```

    ## 2、递归函数设计的三个重要部分

    1. **重要：**给[递归函数]一个明确的语义
    2. 实现边界条件时的程序逻辑
    3. 假设递归函数调用返回结果是正确的，实现本层函数逻辑。

*/


// 1、递归求阶乘
// 解释：阶乘指从1乘以2乘以3乘以4一直乘到所要求的数.
//       例如所要求的数是4,则阶乘式是1×2×3×4,得到的积是24,24就是4的阶乘
int func1(int n)        // 👈 f(n)代表n的阶乘
{
    if(n == 1)  return 1;       // 👈 边界条件：P(1);

    return func1(n - 1) * n;    // 👈 假设递归函数调用返回结果是正确的，实现本层函数逻辑。
                                   // 👈 所以，n的阶乘 = n - 1的阶乘 * n
}

/*
    一堆桃子不知道个数，第一天吃一半，还不过瘾，又多吃了一个。
    以后每天吃剩下的一半多还多一个，到n天只剩下一个桃子了。
    求一开始的桃子总数？

    输入一个整数n(2 ≤ n ≤ 30)。
*/
int func2(int n)    // 👈 f(n)代表能  吃n天桃子的数量
{   
    // 设置边界条件,能吃一天的桃子是1个，因为题目描述第n天只剩下一个桃子（注意：第n天没吃桃子）
    if(n == 1)  return 1;

    return (func2(n - 1) + 1) * 2;
}

/*
    有一个小球掉落在一串连续的弹簧板上，小球落到某一个弹簧板后，会被弹到某一个地点，直到小球被弹到弹簧板以外的地方

    假设有n个连续的弹簧板，每个弹簧板占一个单位距离，a[i]代表第i个弹簧板会把小球向前弹a[i]个距离。
    比如位置1的弹簧能让小球前进2个距离到达位置3。如果小球落到某个弹簧板后，经过一系列弹跳会被弹出弹簧板，
    那么小球就能从这个弹簧板弹出来。

    现在小球掉到了1号弹簧板上面，那么这个小球会被弹起多少次，才会弹出弹簧板。1号弹簧板也算一次。

    输入：

    第一个行输入一个 n 代表一共有 n(1 ≦ n ≦ 100000)个弹簧板
    第二行输入 n 个数字，中间用空格分开。第i个数字 a[i](0 < a[i] ≦ 30)

    样例输入：

    5
    2 2 3 1 2

    样例输出： 2


    分析：
    1、f(i) 小球从 i 位置开始被弹出的次数
    2、i >= n => 0;
    3、f(i) = f(i + a[i]) + 1
*/
int func3(int i, std::vector<int>& arr, int n)
{
    if(i >= n)  return 0;

    return func3(i + arr[i], arr, n) + 1;
}


/*
    从 1 ~ n 这 n 个整数中随机选取任意多个，每种方案里的数从小到大排列，按字典序输出所有可能的选择方案。

    输入：
        一个整数n。（1 <= n <= 10）

    输出：
        每行一组方案。每组方案中两个数之间用空格分割。
        注意每行最后一个数后没有空格

    样例输入：3

    样例输出：
        1
        1 2
        1 2 3
        1 3
        2
        2 3
        3


    解题思路：  
    
    1、 f(i, j, n)    i代表当前枚举第i位的值  | j代表当前最小可以选取的数字 ｜ n代表最大可以选取的数字

    2、 当 j > n => 返回

    3、f(i, j, n)  等价于 =>
            [
                j + f(i + 1, j + 1, n), 
                j + 1 + f(i + 1, j + 2, n), 
                j + 2 + f(i + 1, j + 3, n),
                ...
                n + f(i + 1, n + 1, n)
            ]
*/
void func4(int i, int j, int n)
{   
    static std::array<int, 10> arr;

    // 打印函数
    auto print_one_result = [&](int n) {
        for (int i = 0; i <= n; i++) 
        {
            if(i)   std::cout << "";
            std::cout << arr[i];
        }

        std::cout << std::endl;

        return;
    };

    if(j > n)   return;

    for (int k = j; k <= n; k++) 
    {
        arr[i] = k;
        print_one_result(i);

        func4(i + 1, k + 1, n);
    }

    return;
}



int main()
{
    std::cout << "求4的阶乘：" << func1(4) << std::endl;
    std::cout << "能吃4天的桃子的总数：" << func2(4) << std::endl;


    // int n;
    // std::cin >> n;

    // std::vector<int> arr;
    // int i = 0, a;

    // for (; i < n; i++) 
    // {
    //     std::cin >> a;
    //     arr.push_back(a);
    // }

    // std::cout << "小球被弹起：" << func3(0, arr, n) << "次" << std::endl;



    func4(0, 1, 3);

    
    return 0;
}