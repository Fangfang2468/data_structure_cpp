# 数据结构与算法

## 一、复杂度的分析方法

> 复杂度是程序中最重要的一项审美标准

**时间复杂度：** 程序的运行效率

**空间复杂度：** 内存的消耗

**大〇表示法：用于描述函数渐进行为的数学符号。**

1) 用常数1取代运行时间中的所有加法常数。

2) 在修改后的运行次数函数中，只保留最高阶层项。

3) 如果最高阶项存在且不是1，则去除与这个项目相乘的常数

> 总结：系数归一、常数归一、保留最高次项。

### 复杂度常见案例

#### O(1) 时间复杂度

``` c++
int main()
{
    int a1, n, d, sum = 0;
    cin >> a1 >> n >> d;
    sum = (a1 + a2 + (n - 1) * d) * n / 2;
    std::cout << sum << end;
    return 0;
}
```

#### O(n) 时间复杂度

``` c++
int main()
{   
    // 定义了4个变量
    int a1, n, d, sum = 0;
    cin >> a1 >> n >> d;
    // i，j初始化运行了两次；i，j相加运行了两次；循环了n次，
    // 定义了i和j，两个变量
    // 加起来为6，空间复杂度为 O(1)
    for(int i = a1, j = 0; j < n; i += d, j++)
    {   
        // 相加运行了一次，循环了n次
        sum += i;
    }
    // 加起来运行次数为 3n + 2
    // 时间复杂度为 O(n)
    std::cout << sum << endl;

    return 0;
}
```

#### O(n²)时间复杂度

``` c++
int main()
{
    int n;
    cin >> n;
    
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < n; j++)
        {
            // TODO
        }
    }

    return 0;
}
```

#### O(logN)时间复杂度

``` c++
int main()
{
    int n;
    cin >> n;

    // 执行次数 log₃N
    for(int i = 1; i <= n; i *= 3)
    {
        std::cout << i << endl;
    }

    return 0;
}
```

#### O(nm)时间复杂度

``` c++
int main()
{
    int n, m;
    cin >> n >> m;

    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            // TODO
        }
    }

    return 0;
}
```

#### O(n + m)时间复杂度

``` c++
int main()
{
    int n, m;
    cin >> n >> m;

    for(int i = 0; i < n; i++)
    {
        std::cout << i << std::end;
    }

    for(int i = 0; i < m; i++)
    {
        std::cout << i << std::end;
    }

    return 0;
}
```


## 递归函数的设计技巧

### 1、数学归纳法

什么是数学归纳法？

例：如何证明P(n)成立？

1) Step1：验证P(1)成立
2) Step2：证明如果P(K)成立，那么P(K + 1)也成立
3) Step3：联合Step1与Step2，证明由P(1) -> P(n)成立

**题目一：**

证明：1 + 3 + ... + (2n - 1) = n² 👈 （证明前n项的奇数和等于n次方）

``` 
第一步：证明P(1)
👉  P(1) = 1 = 1²

第二步：假设P(K)正确，证明P(K + 1)
👉  假设P(n - 1) = (n - 1)²
👉  那么，前n - 1项的奇数和 + 第n项的奇数为：(n - 1)²+(2n - 1)
👉  上述式子`(n - 1)²+(2n - 1)`展开化简后等于：n²。
👉  至此，证明了如果P(K)正确，P(K + 1)也正确

第三步：
👉  因为，P(1)正确，又因为：假设P(K)正确，P(K + 1)也正确，
👉  所以：`1 + 3 + ... + (2n - 1) = n²`式子正确 
```

**题目二：**

证明如下程序的正确性👇

``` C++
int main() 
{
    int sum = 0;                            👈 这个是p(1),前0项的和
    for(int i = 1; i <= 100; i++) {         👈 i代表了K + 1
        sum += i;                           👈 sum代表了p(K)，前K项的和，i = K + 1，所以该行执行完后，sum代表前K + 1项的和,P(K + 1)
    }

    cout << sum << endl;
    return 0;
}
```

### 2、递归函数设计的三个重要部分

1. **重要：** 给[递归函数]一个明确的语义
2. 实现边界条件时的程序逻辑
3. 假设递归函数调用返回结果是正确的，实现本层函数逻辑。